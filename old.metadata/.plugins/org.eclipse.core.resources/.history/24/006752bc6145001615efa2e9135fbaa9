// UMC Drive 3 Smart Drive Unit test script

//
// **************************************************************************
// the includes

// system includes
#include <math.h>

// modules
#include "modules/math/src/32b/math.h"
#include "modules/memCopy/src/memCopy.h"

// drivers

// platforms
#include "main.h"

// **************************************************************************
// the defines

#define LED_BLINK_FREQ_Hz   5

// **************************************************************************
// the globals

uint_least32_t gLEDcnt = 0; // Counter used to divide down the ISR rate for visually blinking an LED

HAL_Handle halHandle;       // Handle to the Inverter hardware abstraction layer

USER_Params gUserParams;                      // Contains the user.h settings

HAL_PwmData_t gPwmData = { 0, 0, 0 }; // Contains PWM duty cycles in global Q format
HAL_DacData_t gPwmDacData = { 0, 0, 0, 0 }; // Contains PWM DAC duty cycles in global Q format

HAL_AdcData_t gAdcData = { 0, 0, 0, 0, 0, 0, 0 }; // Contains Current and Voltage ADC readings in global Q format

HAL_AdcSec_t gAdcDataSec = { 0, 0, 0, 0, 0, 0, 0, 0 }; // Contains Current and Voltage ADC readings in global Q format

// Encoder angle
_iq angle = _IQ(0.0);

volatile MOTOR_Vars_t gMotorVars = MOTOR_Vars_INIT;

// Encoder (QEP)
		ENC_Handle encHandle;
		ENC_Obj enc;

		// Print variables
		typedef struct _DebugVariables_t_
		{
			_iq  batt_kV;
			_iq  batt_kA;
			_iq  bus_kV;
			_iq	 phase_kV[3];
			_iq  phase_A[3];
		} DebugVariables_t;

		DebugVariables_t gDebugVars;

#ifdef FLASH
// Used for running BackGround in flash, and ISR in RAM
		extern uint16_t *RamfuncsLoadStart, *RamfuncsLoadEnd, *RamfuncsRunStart;

#ifdef F2802xF
		extern uint16_t *econst_start, *econst_end, *econst_ram_load;
		extern uint16_t *switch_start, *switch_end, *switch_ram_load;
#endif

#endif

// **************************************************************************
// the functions

void main(void) {
	// Only used if running from FLASH
	// Note that the variable FLASH is defined by the project
#ifdef FLASH
	// Copy time critical code and Flash setup code to RAM
	// The RamfuncsLoadStart, RamfuncsLoadEnd, and RamfuncsRunStart
	// symbols are created by the linker. Refer to the linker files.
	memCopy((uint16_t *)&RamfuncsLoadStart,(uint16_t *)&RamfuncsLoadEnd,(uint16_t *)&RamfuncsRunStart);

#ifdef F2802xF
	//copy .econst to unsecure RAM
	if(*econst_end - *econst_start)
	{
		memCopy((uint16_t *)&econst_start,(uint16_t *)&econst_end,(uint16_t *)&econst_ram_load);
	}

	//copy .switch ot unsecure RAM
	if(*switch_end - *switch_start)
	{
		memCopy((uint16_t *)&switch_start,(uint16_t *)&switch_end,(uint16_t *)&switch_ram_load);
	}
#endif

#endif

	// initialize the hardware abstraction layer
	halHandle = HAL_init(&hal, sizeof(hal));

	// check for errors in user parameters
	//USER_checkForErrors(&gUserParams);

	// store user parameter error in global variable
	gMotorVars.UserErrorCode = USER_getErrorCode(&gUserParams);
	gMotorVars.UserErrorCode = USER_ErrorCode_NoError;

	// do not allow code execution if there is a user parameter error
	if (gMotorVars.UserErrorCode != USER_ErrorCode_NoError) {
		for (;;) {
			gMotorVars.Flag_enableSys = false;
		}
	}

	// initialize the user parameters
	USER_setParams(&gUserParams);

	// set the hardware abstraction layer parameters
	HAL_setParams(halHandle, &gUserParams);

	// setup faults
	//HAL_setupFaults(halHandle);

	// initialize the interrupt vector table
	HAL_initIntVectorTable(halHandle);

	// enable the ADC interrupts
	HAL_enableAdcInts(halHandle);

	// enable the CAN interrupt
	HAL_enableCANInts(halHandle);

	// enable the SCI interrupt
	HAL_enableSciRxInts(halHandle);

	// enable global interrupts
	HAL_enableGlobalInts(halHandle);

	// enable debug interrupts
	HAL_enableDebugInt(halHandle);

	// initialize the ENC module
	encHandle = ENC_init(&enc, sizeof(enc));

	// setup the ENC module
	ENC_setup(encHandle, 1, USER_MOTOR_NUM_POLE_PAIRS, USER_MOTOR_ENCODER_LINES,
			0, USER_IQ_FULL_SCALE_FREQ_Hz, USER_ISR_FREQ_Hz, 8000.0);

	// disable the PWM
	HAL_disablePwm(halHandle);
	// enable PWMs
	//HAL_enablePwm(halHandle);

	// SMART EV drivers (probably) need this pin to enable PWMs:
	GPIO_setHigh(((HAL_Obj *) halHandle)->gpioHandle, GPIO_Number_6);

	// For ever loop
	while (true)
		;

} // end of main() function

interrupt void mainISR(void) {

	// toggle status LED
	if (gLEDcnt++ > (uint_least32_t) (USER_ISR_FREQ_Hz / LED_BLINK_FREQ_Hz)) {
		HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);
		gLEDcnt = 0;
		SCI_write(((HAL_Obj *) halHandle)->sciHandle[0], 'x');

		// CAN prepare packet and send. CAN_MboxNum_5 sends 8bytes (max)
		CAN_write(((HAL_Obj *) halHandle)->canHandle, CAN_MboxNum_5,
				(uint32_t) 0x12345678, (uint32_t) 0x9ABCDEF0); // transmits as 0x9A 0xBC 0x DE 0xF0 0x12 0x34 0x56 0x78
		CAN_send(((HAL_Obj *) halHandle)->canHandle, CAN_MBOX_5); // Set TRS for the transmit mailbox
		((CAN_Obj *) ((HAL_Obj *) halHandle)->canHandle)->CANCTRL.CANTA =
		CAN_MBOX_5;

	}

	// compute the electrical angle
	ENC_calcElecAngle(encHandle, HAL_getQepPosnCounts(halHandle));
	angle = ENC_getElecAngle(encHandle);

	// acknowledge the ADC interrupt
	HAL_acqAdcInt(halHandle, ADC_IntNumber_1);

	// convert the ADC data
	HAL_readAdcData(halHandle, &gAdcData);
	HAL_readAdcSecondary(halHandle, &gAdcDataSec);

	// ADC processing and pwm result code goes here

	// write the PWM compare values
	HAL_writePwmData(halHandle, &gPwmData);

	// Frequencies for DAC1 and DAC2: 3000->10kHz, 1500->20kHz, 1000-> 30kHz, 500->60kHz
	HAL_writeDacData(halHandle, &gPwmDacData);

	DebugDisplay();
	return;
} // end of mainISR() function

void DebugDisplay() {
	// Store four channels into OBS memory
	/*
	 DlogCh1 = _IQtoQ15(gAdcData.V.value[0]); //_IQtoQ15(InvSine);
	 DlogCh2 = _IQtoQ15(gAdcData.V.value[1]);
	 DlogCh3 = _IQtoQ15(gAdcData.I.value[0]);
	 DlogCh4 = _IQtoQ15(InvSine); //gAdcData.I.value[1]);
	 dlog.update(&dlog);
	 */
	gDebugVars.phase_kV[0] = _IQmpy(gAdcData.V.value[0],
			_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V));
	gDebugVars.phase_kV[1] = _IQmpy(gAdcData.V.value[1],
			_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V));
	gDebugVars.phase_kV[2] = _IQmpy(gAdcData.V.value[2],
			_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V));

	gDebugVars.phase_A[0] = _IQmpy(gAdcData.I.value[0],
			_IQ(USER_IQ_FULL_SCALE_CURRENT_A));
	gDebugVars.phase_A[1] = _IQmpy(gAdcData.I.value[1],
			_IQ(USER_IQ_FULL_SCALE_CURRENT_A));
	gDebugVars.phase_A[2] = _IQmpy(gAdcData.I.value[2],
			_IQ(USER_IQ_FULL_SCALE_CURRENT_A));

	//gDebugVars.batt_kV = _IQmpy(gAdcData.dcBus,	_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V));
	//gDebugVars.bus_kV = _IQmpy(gAdcSecondary.batt_V,_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V));

	//gDebugVars.busPrius_kV = gAdcSecondary.busPrius_V;
	//gDebugVars.tempA_deg = gAdcSecondary.igbtTempMG1;
	//gDebugVars.tempB_deg = gAdcSecondary.igbtTempMG2;
	//gDebugVars.tempC_deg = gAdcSecondary.igbtTempBoost;
}

interrupt void Can0ISR(void) {
	// How should we know which message was received?
	CAN_clearRxInt(((HAL_Obj *) halHandle)->canHandle,
	CAN_MBOX_1 | CAN_MBOX_2 | CAN_MBOX_3 | CAN_MBOX_4);
	HAL_acqCANInt(halHandle);
	HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);
	return;
}

volatile uint16_t command;

interrupt void SciaRxISR(void) {

	HAL_acqSciRxInt(halHandle);

	HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);
	/*
	 SCI_write(((HAL_Obj *) halHandle)->sciHandle[0],
	 SCI_read(((HAL_Obj *) halHandle)->sciHandle[0]));
	 */

	command = SCI_read(((HAL_Obj *) halHandle)->sciHandle[0]);
	//SCI_write(((HAL_Obj *) halHandle)->sciHandle[0], command);

	//SCI_clearRxFifoInt(((HAL_Obj *) halHandle)->sciHandle[0]);
	//SCI_clearRxFifoOvf(((HAL_Obj *) halHandle)->sciHandle[0]);

	return;
}

//@} //defgroup
// end of file

