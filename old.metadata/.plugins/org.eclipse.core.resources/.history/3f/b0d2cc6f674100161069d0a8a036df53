// **************************************************************************
// the includes

#include "drivers/i2c/src/32b/f28x/f2806x/i2c.h"

// **************************************************************************
// the defines

// **************************************************************************
// the globals

// **************************************************************************
// the functions

void I2C_clearRxFifoInt(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// set the bits
	i2c->I2CFFRX |= I2C_I2CFFRX_RXFFINTCLR_BITS;

	return;
}

void I2C_clearTxFifoInt(I2C_Handle sciHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// set the bits
	i2c->I2CFFTX |= I2C_I2CFFTX_TXFFINTCLR_BITS;

	return;
} // end of SCI_clearTxFifoInt() function

void I2C_disable(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// clear the bits
	//i2c->SCICTL1 &= (~SCI_SCICTL1_RESET_BITS);

	return;
} // end of SCI_disable() function

/*
 void SPI_clearRxFifoOvf(SPI_Handle spiHandle)
 {
 SPI_Obj *spi = (SPI_Obj *)spiHandle;


 // set the bits
 spi->SPIFFRX |= SPI_SPIFFRX_FIFO_OVFCLR_BITS;

 return;
 } // end of SPI_clearRxFifoOvf() function
 */

void I2C_setSlaveAddress(I2C_Handle i2cHandle, uint16_t address) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	i2c->I2CSAR = address;
}

void I2C_setFrequency(I2C_Handle i2cHandle, uint16_t frequency) {
	// TODO: calculate frequency instead of a fixed value
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	// module frequency = I2C input clk / (IPSC + 1)
	i2c->I2CPSC = 8; // should be 90Mhz/9 = 10MHz
	i2c->I2CCLKL = 10; // To be modified later
	i2c->I2CCLKH = 5; // To be modified later
}

I2C_Handle I2C_init(void *pMemory, const size_t numBytes) {
	I2C_Handle i2cHandle;

	if (numBytes < sizeof(I2C_Obj))
		return ((I2C_Handle) NULL);

	// assign the handle
	i2cHandle = (I2C_Handle) pMemory;

	return (i2cHandle);
} // end of SCI_init() function

/*
 void I2C_Init(void)
 {
 // Initialize I2C
 I2caRegs.I2CSAR = 0x0050;		// Slave address - EEPROM control code

 I2caRegs.I2CPSC.all = 6;		    // Prescaler - need 7-12 Mhz on module clk
 I2caRegs.I2CCLKL = 10;			// NOTE: must be non zero
 I2caRegs.I2CCLKH = 5;			// NOTE: must be non zero
 I2caRegs.I2CIER.all = 0x24;		// Enable SCD & ARDY interrupts

 I2caRegs.I2CMDR.all = 0x0020;	// Take I2C out of reset
 // Stop I2C when suspended

 I2caRegs.I2CFFTX.all = 0x6000;	// Enable FIFO mode and TXFIFO
 I2caRegs.I2CFFRX.all = 0x2040;	// Enable RXFIFO, clear RXFFINT,

 return;
 }
 */

void I2C_putDataBlocking(I2C_Handle i2cHandle, struct _I2C_Msg_ *msg) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	uint16_t i;

	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	while ((i2c->I2CMDR & I2C_I2CMDR_STP_BITS) != 0) {
	}

	// Slave address
	i2c->I2CSAR = msg->SlaveAddress;

	// Check if bus busy
	while ((i2c->I2CSTR & I2C_I2CSTR_BB_BITS) != 0) {
	}

	// Setup number of bytes to send
	// MsgBuffer + Address
	i2c->I2CCNT = msg->NumOfBytes + 2;

	// Setup data to send
	i2c->I2CDXR = msg->MemoryHighAddr;
	i2c->I2CDXR = msg->MemoryLowAddr;
	// for (i=0; i<msg->NumOfBytes-2; i++)
	for (i = 0; i < msg->NumOfBytes; i++)

	{
		i2c->I2CDXR = *(msg->MsgBuffer + i);
	}

	// Send start as master transmitter
	i2c->I2CMDR = 0x6E20;

	return;
}
/*
Uint16 I2C_WriteData(struct I2CMSG *msg) {
	Uint16 i;

	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if (I2caRegs.I2CMDR.bit.STP == 1) {
		return I2C_STP_NOT_READY_ERROR;
	}

	// Setup slave address
	I2caRegs.I2CSAR = msg->SlaveAddress;

	// Check if bus busy
	if (I2caRegs.I2CSTR.bit.BB == 1) {
		return I2C_BUS_BUSY_ERROR;
	}

	// Setup number of bytes to send
	// MsgBuffer + Address
	I2caRegs.I2CCNT = msg->NumOfBytes + 2;

	// Setup data to send
	I2caRegs.I2CDXR = msg->MemoryHighAddr;
	I2caRegs.I2CDXR = msg->MemoryLowAddr;
// for (i=0; i<msg->NumOfBytes-2; i++)
	for (i = 0; i < msg->NumOfBytes; i++)

	{
		I2caRegs.I2CDXR = *(msg->MsgBuffer + i);
	}

	// Send start as master transmitter
	I2caRegs.I2CMDR.all = 0x6E20;

	return I2C_SUCCESS;
}
*/

/*
Uint16 I2C_ReadData(struct I2CMSG *msg) {
	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if (I2caRegs.I2CMDR.bit.STP == 1) {
		return I2C_STP_NOT_READY_ERROR;
	}

	I2caRegs.I2CSAR = msg->SlaveAddress;

	if (msg->MsgStatus == I2C_MSGSTAT_SEND_NOSTOP) {
		// Check if bus busy
		if (I2caRegs.I2CSTR.bit.BB == 1) {
			return I2C_BUS_BUSY_ERROR;
		}
		I2caRegs.I2CCNT = 2;
		I2caRegs.I2CDXR = msg->MemoryHighAddr;
		I2caRegs.I2CDXR = msg->MemoryLowAddr;
		I2caRegs.I2CMDR.all = 0x2620;		// Send data to setup EEPROM address
	} else if (msg->MsgStatus == I2C_MSGSTAT_RESTART) {
		I2caRegs.I2CCNT = msg->NumOfBytes;	// Setup how many bytes to expect
		I2caRegs.I2CMDR.all = 0x2C20;		// Send restart as master receiver
	}

	return I2C_SUCCESS;
}
*/
