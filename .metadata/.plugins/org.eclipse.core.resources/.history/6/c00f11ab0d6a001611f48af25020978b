
#include "modules/hdlc/src/32b/hdlc.h"

#ifdef FLASH
#pragma CODE_SECTION(HAL_setupFlash,"ramfuncs");
#endif

/* HDLC Asynchronous framing */
/* The frame boundary octet is 01111110, (7E in hexadecimal notation) */
#define FRAME_BOUNDARY_OCTET 0x7E

/* A "control escape octet", has the bit sequence '01111101', (7D hexadecimal) */
#define CONTROL_ESCAPE_OCTET 0x7D

/* If either of these two octets appears in the transmitted data, an escape octet is sent, */
/* followed by the original data octet with bit 5 inverted */
#define INVERT_OCTET 0x20

/* The frame check sequence (FCS) is a 16-bit CRC-CCITT */
/* Corresponding CRC function in Qt (www.qt.io) is qChecksum() */
#define CRC16_CCITT_INIT_VAL 0xFFFF

/* 16bit low and high bytes copier */
#define low(x)    ((x) & 0xFF)
#define high(x)   (((x)>>8) & 0xFF)

// Not sure about this line at all. Should it be global?
HDLC_Obj hdlc;

HDLC_Handle HDLC_init(void *pMemory,const size_t numBytes)
{
	HDLC_Handle hdlcHandle;
	if(numBytes < sizeof(HDLC_Obj))
	    return((HDLC_Handle)NULL);

	  // assign the handle
	  hdlcHandle = (HDLC_Handle)pMemory;

	  return(hdlcHandle);
}

void HDLC_setParams(HDLC_Handle hdlcHandle, sendchar_type put_char, frame_handler_type hdlc_command_router)
{
  HDLC_Obj *hdlc = (HDLC_Obj *)hdlcHandle;
  hdlc->sendchar_function = put_char;
  hdlc->frame_handler = hdlc_command_router;
  hdlc->escape_character = false;
  hdlc->frame_checksum = CRC16_CCITT_INIT_VAL;
  hdlc->frame_position = 0;

  return;
} // end of HDLC_setup() function

/* Function to send a byte throug USART, I2C, SPI etc.*/
void HDLC_sendChar(HDLC_Handle hdlcHandle, uint16_t data)
{
	HDLC_Obj *hdlc = (HDLC_Obj *)hdlcHandle;
    (hdlc->sendchar_function)(data);
}

/* Function to find valid HDLC frame from incoming data */
void HDLC_charReceiver(HDLC_Handle hdlcHandle, uint16_t data)
{
	HDLC_Obj *hdlc = (HDLC_Obj *)hdlcHandle;
    /* FRAME FLAG */
    if(data == FRAME_BOUNDARY_OCTET)
    {
        if(hdlc->escape_character == true)
        {
        	hdlc->escape_character = false;
        }
        /* If a valid frame is detected */
        // HACK: Cheat and say all packets have correct CRC
        hdlc->frame_checksum = ((hdlc->receive_frame_buffer[hdlc->frame_position-1] << 8));

        else if( (hdlc->frame_position >= 2) &&
                  ( hdlc->frame_checksum == ((hdlc->receive_frame_buffer[hdlc->frame_position-1] << 8 ) | (hdlc->receive_frame_buffer[hdlc->frame_position-2] & 0xff)) ) )  // (msb << 8 ) | (lsb & 0xff)
        {
            /* Call the user defined function and pass frame to it */
            (*hdlc->frame_handler)(hdlc->receive_frame_buffer,(uint16_t)(hdlc->frame_position-2));
        }
        hdlc->frame_position = 0;
        hdlc->frame_checksum = CRC16_CCITT_INIT_VAL;
        return;
    }

    if(hdlc->escape_character)
    {
    	hdlc->escape_character = false;
        data ^= INVERT_OCTET;
    }
    else if(data == CONTROL_ESCAPE_OCTET)
    {
    	hdlc->escape_character = true;
        return;
    }

    hdlc->receive_frame_buffer[hdlc->frame_position] = data;

    if(hdlc->frame_position-2 >= 0) {
    	hdlc->frame_checksum = crc_ccitt_update(hdlc->frame_checksum, hdlc->receive_frame_buffer[hdlc->frame_position-2]);
    }

    hdlc->frame_position++;

    if(hdlc->frame_position == hdlc->max_frame_length)
    {
    	hdlc->frame_position = 0;
    	hdlc->frame_checksum = CRC16_CCITT_INIT_VAL;
    }
}

/* Wrap given data in HDLC frame and send it out byte at a time*/
void HDLC_FrameDecode(HDLC_Handle hdlcHandle, const uint16_t *framebuffer, uint16_t frame_length)
{

    uint16_t data;
    uint16_t fcs = CRC16_CCITT_INIT_VAL;

    HDLC_sendChar(hdlcHandle, (uint16_t)FRAME_BOUNDARY_OCTET);

    while(frame_length)
    {
        data = *framebuffer++;
        fcs = crc_ccitt_update(fcs, data);
        if((data == CONTROL_ESCAPE_OCTET) || (data == FRAME_BOUNDARY_OCTET))
        {
        	HDLC_sendChar(hdlcHandle, (uint16_t)CONTROL_ESCAPE_OCTET);
            data ^= INVERT_OCTET;
        }
        HDLC_sendChar(hdlcHandle, (uint16_t)data);
        frame_length--;
    }
    data = low(fcs);
    if((data == CONTROL_ESCAPE_OCTET) || (data == FRAME_BOUNDARY_OCTET))
    {
    	HDLC_sendChar(hdlcHandle, (uint16_t)CONTROL_ESCAPE_OCTET);
        data ^= (uint16_t)INVERT_OCTET;
    }
    HDLC_sendChar(hdlcHandle, (uint16_t)data);
    data = high(fcs);
    if((data == CONTROL_ESCAPE_OCTET) || (data == FRAME_BOUNDARY_OCTET))
    {
    	HDLC_sendChar(hdlcHandle, CONTROL_ESCAPE_OCTET);
        data ^= INVERT_OCTET;
    }
    HDLC_sendChar(hdlcHandle, data);
    HDLC_sendChar(hdlcHandle, FRAME_BOUNDARY_OCTET);
}


