#include "modules/motorware/src/32b/motorware.h"

#ifdef FAST_ROM_V1p6
CTRL_Obj *controller_obj;
#else
CTRL_Obj ctrl;				//v1p7 format
#endif

bool Flag_Latch_softwareUpdate = true;
uint_least16_t gCounter_updateGlobals = 0;
USER_Params gUserParams;
//volatile MOTOR_Vars_t gMotorVars = MOTOR_Vars_INIT;
extern MOTOR_Vars_t gMotorVars;

_iq gMaxCurrentSlope = _IQ(0.0);

_iq gFlux_pu_to_Wb_sf;
_iq gFlux_pu_to_VpHz_sf;
_iq gTorque_Ls_Id_Iq_pu_to_Nm_sf;
_iq gTorque_Flux_Iq_pu_to_Nm_sf;

// Two throttles
//THROTTLE_Handle throttleHandle[2];
//THROTTLE_Obj throttle[2];

void MOTORWARE_init(HAL_Handle halHandle, CTRL_Handle ctrlHandle,
		ENC_Handle encHandle, DEFAULTS_Memory * memory) {

	// Only used if running from FLASH
	// Note that the variable FLASH is defined by the project
#ifdef FLASH
	// Copy time critical code and Flash setup code to RAM
	// The RamfuncsLoadStart, RamfuncsLoadEnd, and RamfuncsRunStart
	// symbols are created by the linker. Refer to the linker files.
	memCopy((uint16_t *)&RamfuncsLoadStart,(uint16_t *)&RamfuncsLoadEnd,(uint16_t *)&RamfuncsRunStart);
#endif

	// initialize the hardware abstraction layer
	//halHandle = HAL_init(&hal, sizeof(hal));

	// Initialize both throttle segments
	//throttleHandle[0] = THROTTLE_init(&throttle[0], sizeof(throttle[0]));
	//throttleHandle[1] = THROTTLE_init(&throttle[1], sizeof(throttle[1]));
	// We start with non inverted, max = 0, min = 1, output scaled as 0-1
	//THROTTLE_setParams(throttleHandle[0], false, _IQ(0.0), _IQ(5.0), _IQ(1.0),_IQ(0.0));
	// Second channel is inverted
	//THROTTLE_setParams(throttleHandle[1], true, _IQ(0.0), _IQ(5.0), _IQ(1.0),_IQ(0.0));
	//THROTTLE_setup(throttleHandle[0], _IQ(0.0), false, false);
	//THROTTLE_setup(throttleHandle[1], _IQ(0.0), false, false);

	// check for errors in user parameters
	USER_checkForErrors(&gUserParams);

	// store user parameter error in global variable
	gMotorVars.UserErrorCode = USER_getErrorCode(&gUserParams);

	// do not allow code execution if there is a user parameter error
	if (gMotorVars.UserErrorCode != USER_ErrorCode_NoError) {
		for (;;) {
			gMotorVars.Flag_enableSys = false;
		}
	}

	// initialize the user parameters
	USER_setParams(&gUserParams, memory);

	// set the hardware abstraction layer parameters
	//HAL_setParams(halHandle, &gUserParams);
	HAL_setParams(halHandle, &gUserParams);

	// initialize the controller

	//ctrlHandle = CTRL_initCtrl(ctrlNumber, estNumber); //v1p6 format (06xF and 06xM devices)
	controller_obj = (CTRL_Obj *) ctrlHandle;

	{
		CTRL_Version version;

		// get the version number
		CTRL_getVersion(ctrlHandle, &version);

		gMotorVars.CtrlVersion = version;
	}

	// set the default controller parameters
	CTRL_setParams(ctrlHandle, &gUserParams);

	// setup faults
	//HAL_setupFaults(halHandle);

	// initialize the interrupt vector table
	HAL_initIntVectorTable(halHandle);

#ifdef ENCODER
	// initialize the ENC module
	//encHandle = ENC_init(&enc, sizeof(enc));

	// setup the ENC module
	ENC_setup(encHandle, 1, USER_MOTOR_NUM_POLE_PAIRS, USER_MOTOR_ENCODER_LINES,
			0, USER_IQ_FULL_SCALE_FREQ_Hz, USER_ISR_FREQ_Hz, 8000.0);
#endif

	// Dis-able the Library internal PI.  Iq has no reference now
	CTRL_setFlag_enableSpeedCtrl(ctrlHandle, false);

	// enable DC bus compensation
	CTRL_setFlag_enableDcBusComp(ctrlHandle, true);

	// compute scaling factors for flux and torque calculations
	gFlux_pu_to_Wb_sf = USER_computeFlux_pu_to_Wb_sf();
	gFlux_pu_to_VpHz_sf = USER_computeFlux_pu_to_VpHz_sf();
	gTorque_Ls_Id_Iq_pu_to_Nm_sf = USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf();
	gTorque_Flux_Iq_pu_to_Nm_sf = USER_computeTorque_Flux_Iq_pu_to_Nm_sf();

	// ENABLE offsets recalibration by default
	gMotorVars.Flag_enableOffsetcalc = true;

}

void MOTORWARE_enableInts(HAL_Handle halHandle) {

	// enable the ADC interrupts
	HAL_enableAdcInts(halHandle);

	// enable the CAN interrupt
	HAL_enableCANInts(halHandle);

	// enable the SCI interrupt
	HAL_enableSciRxInts(halHandle);

	// enable global interrupts
	HAL_enableGlobalInts(halHandle);

	// enable debug interrupts
	HAL_enableDebugInt(halHandle);

	// disable the PWM
	HAL_disablePwm(halHandle);

}

void MOTORWARE_updateGlobalVariables_motor(CTRL_Handle handle,
		HAL_AdcData_t gAdcData) {
	CTRL_Obj *obj = (CTRL_Obj *) handle;
	int32_t tmp;

	// get the speed estimate
	gMotorVars.Speed_krpm = EST_getSpeed_krpm(obj->estHandle);

	// get the torque estimate
	gMotorVars.Torque_Nm = USER_computeTorque_Nm(handle,
			gTorque_Flux_Iq_pu_to_Nm_sf, gTorque_Ls_Id_Iq_pu_to_Nm_sf);

	// when calling EST_ functions that return a float, and fpu32 is enabled, an integer is needed as a return
	// so that the compiler reads the returned value from the accumulator instead of fpu32 registers
	// get the magnetizing current
	tmp = EST_getIdRated(obj->estHandle);
	gMotorVars.MagnCurr_A = *((float_t *) &tmp);

	// get the rotor resistance
	tmp = EST_getRr_Ohm(obj->estHandle);
	gMotorVars.Rr_Ohm = *((float_t *) &tmp);

	// get the stator resistance
	tmp = EST_getRs_Ohm(obj->estHandle);
	gMotorVars.Rs_Ohm = *((float_t *) &tmp);

	// get the stator inductance in the direct coordinate direction
	tmp = EST_getLs_d_H(obj->estHandle);
	gMotorVars.Lsd_H = *((float_t *) &tmp);

	// get the stator inductance in the quadrature coordinate direction
	tmp = EST_getLs_q_H(obj->estHandle);
	gMotorVars.Lsq_H = *((float_t *) &tmp);

	// get the flux in V/Hz in floating point
	tmp = EST_getFlux_VpHz(obj->estHandle);
	gMotorVars.Flux_VpHz = *((float_t *) &tmp);

	// get the flux in Wb in fixed point
	gMotorVars.Flux_Wb = USER_computeFlux(handle, gFlux_pu_to_Wb_sf);

	// get the controller state
	gMotorVars.CtrlState = CTRL_getState(handle);

	// get the estimator state
	gMotorVars.EstState = EST_getState(obj->estHandle);

	// Get the DC buss voltage
	gMotorVars.VdcBus_kV = _IQmpy(gAdcData.dcBus,
			_IQ(USER_IQ_FULL_SCALE_VOLTAGE_V/1000.0));

	return;
} // end of updateGlobalVariables_motor() function

void MOTORWARE_updateIqRef(CTRL_Handle handle) {
	_iq iq_ref = _IQmpy(gMotorVars.IqRef_A,
			_IQ(1.0/USER_IQ_FULL_SCALE_CURRENT_A));

	// set the speed reference so that the forced angle rotates in the correct direction for startup
	if (_IQabs(gMotorVars.Speed_krpm) < _IQ(0.01)) {
		if (iq_ref < _IQ(0.0)) {
			CTRL_setSpd_ref_krpm(handle, _IQ(-0.01));
		} else if (iq_ref > _IQ(0.0)) {
			CTRL_setSpd_ref_krpm(handle, _IQ(0.01));
		}
	}

	// Set the Iq reference that use to come out of the PI speed control
	CTRL_setIq_ref_pu(handle, iq_ref);

	return;
} // end of updateIqRef() function

void MOTORWARE_runSequencer(HAL_Handle halHandle, CTRL_Handle ctrlHandle,
		HAL_AdcData_t gAdcData, DEFAULTS_Memory * memory) {
	// Waiting for enable system flag to be set
	//while (!(gMotorVars.Flag_enableSys));

	// if system not enabled, return
	//if (!(gMotorVars.Flag_enableSys))
	//return;

	// loop while the enable system flag is true
	if (gMotorVars.Flag_enableSys) {
		CTRL_Obj *obj = (CTRL_Obj *) ctrlHandle;

		// increment counters
		gCounter_updateGlobals++;

		// enable/disable the use of motor parameters being loaded from user.h
		CTRL_setFlag_enableUserMotorParams(ctrlHandle,
				gMotorVars.Flag_enableUserParams);

		// enable/disable Rs recalibration during motor startup
		EST_setFlag_enableRsRecalc(obj->estHandle,
				gMotorVars.Flag_enableRsRecalc);

		// enable/disable automatic calculation of bias values
		CTRL_setFlag_enableOffset(ctrlHandle, gMotorVars.Flag_enableOffsetcalc);

		if (CTRL_isError(ctrlHandle)) {
			// set the enable controller flag to false
			CTRL_setFlag_enableCtrl(ctrlHandle, false);

			// set the enable system flag to false
			gMotorVars.Flag_enableSys = false;

			// disable the PWM
			HAL_disablePwm(halHandle);
		} else {
			// update the controller state
			bool flag_ctrlStateChanged = CTRL_updateState(ctrlHandle);

			// enable or disable the control
			CTRL_setFlag_enableCtrl(ctrlHandle, gMotorVars.Flag_Run_Identify);

			if (flag_ctrlStateChanged) {
				CTRL_State_e ctrlState = CTRL_getState(ctrlHandle);

				if (ctrlState == CTRL_State_OffLine) {
					// enable the PWM
					HAL_enablePwm(halHandle);
				} else if (ctrlState == CTRL_State_OnLine) {
					if (gMotorVars.Flag_enableOffsetcalc == true) {
						// update the ADC bias values
						HAL_updateAdcBias(halHandle);
					} else {
						// set the current bias
						HAL_setBias(halHandle, HAL_SensorType_Current, 0,
								_IQ(memory->instaspin.offsetCurrentA));
						HAL_setBias(halHandle, HAL_SensorType_Current, 1,
								_IQ(memory->instaspin.offsetCurrentB));
						HAL_setBias(halHandle, HAL_SensorType_Current, 2,
								_IQ(memory->instaspin.offsetCurrentC));

						// set the voltage bias
						HAL_setBias(halHandle, HAL_SensorType_Voltage, 0,
								_IQ(V_A_offset));
						HAL_setBias(halHandle, HAL_SensorType_Voltage, 1,
								_IQ(V_B_offset));
						HAL_setBias(halHandle, HAL_SensorType_Voltage, 2,
								_IQ(V_C_offset));
					}

					// Return the bias value for currents
					gMotorVars.I_bias.value[0] = HAL_getBias(halHandle,
							HAL_SensorType_Current, 0);
					gMotorVars.I_bias.value[1] = HAL_getBias(halHandle,
							HAL_SensorType_Current, 1);
					gMotorVars.I_bias.value[2] = HAL_getBias(halHandle,
							HAL_SensorType_Current, 2);

					// Return the bias value for voltages
					gMotorVars.V_bias.value[0] = HAL_getBias(halHandle,
							HAL_SensorType_Voltage, 0);
					gMotorVars.V_bias.value[1] = HAL_getBias(halHandle,
							HAL_SensorType_Voltage, 1);
					gMotorVars.V_bias.value[2] = HAL_getBias(halHandle,
							HAL_SensorType_Voltage, 2);

					// enable the PWM
					HAL_enablePwm(halHandle);
				} else if (ctrlState == CTRL_State_Idle) {
					// disable the PWM
					HAL_disablePwm(halHandle);
					gMotorVars.Flag_Run_Identify = false;
				}

				if ((CTRL_getFlag_enableUserMotorParams(ctrlHandle) == true)
						&& (ctrlState > CTRL_State_Idle)
						&& (gMotorVars.CtrlVersion.minor == 6)) {
					// call this function to fix 1p6
					USER_softwareUpdate1p6(ctrlHandle);
				}

			}
		}

		if (EST_isMotorIdentified(obj->estHandle)) {
			// set the current ramp
			EST_setMaxCurrentSlope_pu(obj->estHandle, gMaxCurrentSlope);
			gMotorVars.Flag_MotorIdentified = true;

			if (Flag_Latch_softwareUpdate) {
				Flag_Latch_softwareUpdate = false;

				USER_calcPIgains(ctrlHandle);
			}

		} else {
			Flag_Latch_softwareUpdate = true;

			// the estimator sets the maximum current slope during identification
			gMaxCurrentSlope = EST_getMaxCurrentSlope_pu(obj->estHandle);
		}

		// when appropriate, update the global variables
		if (gCounter_updateGlobals >= NUM_MAIN_TICKS_FOR_GLOBAL_VARIABLE_UPDATE) {
			// reset the counter
			gCounter_updateGlobals = 0;

			MOTORWARE_updateGlobalVariables_motor(ctrlHandle, gAdcData);
		}

		// update Iq reference
		MOTORWARE_updateIqRef(ctrlHandle);

		// enable/disable the forced angle
		EST_setFlag_enableForceAngle(obj->estHandle,
				gMotorVars.Flag_enableForceAngle);

		// enable or disable power warp
		CTRL_setFlag_enablePowerWarp(ctrlHandle,
				gMotorVars.Flag_enablePowerWarp);

	} // end of while(gFlag_enableSys) loop
	else {
		// disable the PWM
		HAL_disablePwm(halHandle);
		// set the default controller parameters (Reset the control to re-identify the motor)
		CTRL_setParams(ctrlHandle, &gUserParams);
		gMotorVars.Flag_Run_Identify = false;
	}

}
