/* --COPYRIGHT--,BSD
 * Copyright (c) 2016, ADVANTICS INC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of ADVANTICS Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/
//! \defgroup I2C I2C
//@{

// **************************************************************************
#include "drivers/i2c/src/32b/f28x/f2806x/i2c.h"
#include "user.h" // Here is where the definition for the clock frequency must be

// **************************************************************************

void I2C_clearRxFifoInt(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// set the bits
	i2c->I2CFFRX |= I2C_I2CFFRX_RXFFINTCLR_BITS;

	return;
}

void I2C_clearTxFifoInt(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	// set the bits
	i2c->I2CFFTX |= I2C_I2CFFTX_TXFFINTCLR_BITS;
	return;
}

void I2C_disable(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// clear the bits
	i2c->I2CMDR &= (~I2C_I2CMDR_IRS_BITS);
	return;
}

void I2C_enable(I2C_Handle i2cHandle) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	// set the bits
	i2c->I2CMDR |= I2C_I2CMDR_IRS_BITS;
	return;
}

void I2C_enableStopInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR |= I2C_I2CIER_SCD_BITS;
	return;
}

void I2C_disableStopInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR &= (~I2C_I2CIER_SCD_BITS);
	return;
}

void I2C_enableTxRdyInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR |= I2C_I2CIER_XRDY_BITS;
	return;
}

void I2C_disableTxRdyInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR &= (~I2C_I2CIER_XRDY_BITS);
	return;
}

void I2C_enableRxRdyInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR |= I2C_I2CIER_RRDY_BITS;
	return;
}

void I2C_disableRxRdyInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR &= (~I2C_I2CIER_RRDY_BITS);
	return;
}

void I2C_enableARDYInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR |= I2C_I2CIER_ARDY_BITS;
	return;
}

void I2C_disableARDYInt(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CMDR &= (~I2C_I2CIER_ARDY_BITS);
	return;
}

void I2C_enableRXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFRX |= (I2C_I2CFFRX_RXFFRST_BITS) + 0x4;
	return;
}

void I2C_setRXFIFOiLevel(I2C_Handle i2cHandle,uint16_t iLevel){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFRX |= iLevel&0xF;
	return;
}

void I2C_resetRXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFRX &= (~I2C_I2CFFRX_RXFFRST_BITS);
	return;
}
void I2C_disableRXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFRX &= (~I2C_I2CFFRX_RXFFRST_BITS);
	return;
}

void I2C_enableTXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFTX |= (I2C_I2CFFTX_TXFFRST_BITS|I2C_I2CFFTX_I2CFFEN_BITS);
	return;
}

void I2C_setTXFIFOiLevel(I2C_Handle i2cHandle,uint16_t iLevel){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFTX |= iLevel&0xF;
	return;
}

void I2C_resetTXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFTX &= (~I2C_I2CFFTX_TXFFRST_BITS);
	return;
}

void I2C_disableTXFIFO(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;

	i2c->I2CFFTX &= (~I2C_I2CFFTX_TXFFRST_BITS);
	return;
}

void I2C_setFrequency(I2C_Handle i2cHandle, uint16_t systemFreqMHz, bool speed ) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	// module frequency = I2C input clk / (IPSC + 1)
	i2c->I2CPSC = (USER_SYSTEM_FREQ_MHz/10-1); // 10MHz
	// Use 10MHz always to generate the I2C clock
	if (speed) {
		i2c->I2CCLKL = 10; // 400KHz
		i2c->I2CCLKH = 5;
	} else {
		i2c->I2CCLKL = 50; // 100KHz
		i2c->I2CCLKH = 40;
	}
}

I2C_Handle I2C_init(void *pMemory, const size_t numBytes) {
	I2C_Handle i2cHandle;

	if (numBytes < sizeof(I2C_Obj))
		return ((I2C_Handle) NULL);

	// assign the handle
	i2cHandle = (I2C_Handle) pMemory;

	return (i2cHandle);
}

bool I2C_isBusy(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	bool status = false;
	status = (i2c->I2CSTR & I2C_I2CSTR_BB_BITS) >> 7;
	return((bool)status);
}

bool I2C_overrun(I2C_Handle i2cHandle){
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	bool status = false;
	status = (i2c->I2CSTR & I2C_I2CSTR_RSFULL_BITS) >> 7;
	return((bool)status);
}

I2C_Status_t I2C_WriteData(I2C_Handle i2cHandle,I2C_Msg *msg) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	uint16_t i;

	// Generic routine to write data in the I2C bus, wihtout using the FIFO.

	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if ((i2c->I2CMDR & I2C_I2CMDR_STP_BITS) == 1)
		return I2C_STP_NOT_READY_ERROR;

	// Check if bus busy
	if ((i2c->I2CSTR & I2C_I2CSTR_BB_BITS) == 1)
		return I2C_BUS_BUSY_ERROR;

	i2c->I2CMDR = 0; // Reset the I2C module before applying the new settings

	// Setup number of bytes to send
	// MsgBuffer + Address (if address has to be sent, otherwise MsgBuffer)
	switch(msg->MsgType) {
	case I2C_MSG_EEPROM_24LC16:
		i2c->I2CCNT = msg->NumOfBytes+1;
		i2c->I2CSAR = msg->SlaveAddress + (((msg->MemoryAddr)>>8)&0x7);
		break;
	case I2C_MSG_GENERIC:
		i2c->I2CCNT = msg->NumOfBytes;
		i2c->I2CSAR = msg->SlaveAddress;
		break;
	default:
		return I2C_BAD_MSG_TYPE;
	}

	i2c->I2CMDR = (I2C_I2CMDR_STT_BITS|I2C_I2CMDR_STP_BITS|I2C_I2CMDR_MST_BITS|I2C_I2CMDR_TRX_BITS|I2C_I2CMDR_IRS_BITS|I2C_I2CMDR_FREE_BITS); // Start transmission cycle
	while(!(i2c->I2CSTR & (I2C_I2CSTR_XRDY_BITS|I2C_I2CSTR_ARDY_BITS)))
			continue; // Wait until the communication takes place, and then check the ACK
	// Check the ACK from the slave, and signal a failure if not received
	if(i2c->I2CSTR & I2C_I2CSTR_NACK_BITS){
			// Slave not addressed. Fail.
			i2c->I2CMDR |= I2C_I2CMDR_STP_BITS;
			i2c->I2CSTR = I2C_I2CSTR_NACK_BITS; // Clear NACK bit
			return I2C_NACK_ERROR;
		}

	i2c->I2CDXR = msg->MemoryAddr;
	for (i = 0; i < msg->NumOfBytes; i++) {
		while(!(i2c->I2CSTR & (I2C_I2CSTR_XRDY_BITS|I2C_I2CSTR_ARDY_BITS)))
				continue; // Wait until the communication takes place, and then check the ACK
		// Check the ACK from the slave, and signal a failure if not received
		if(i2c->I2CSTR & I2C_I2CSTR_NACK_BITS){
				// Slave not addressed. Fail.
				i2c->I2CMDR |= I2C_I2CMDR_STP_BITS;
				i2c->I2CSTR = I2C_I2CSTR_NACK_BITS; // Clear NACK bit
				return I2C_NACK_ERROR;
			}
		i2c->I2CDXR = *(msg->MsgBuffer + i);
	}

	// The status of this operation will be reported from the ISR, if enabled, or by polling the
	// status bits
	while(i2c->I2CMDR & I2C_I2CMDR_MST_BITS)
		continue;
	return I2C_SUCCESS;
}

I2C_Status_t I2C_ReadData(I2C_Handle i2cHandle,I2C_Msg *msg) {
	I2C_Obj *i2c = (I2C_Obj *) i2cHandle;
	uint16_t i;

	// Generic routine to read data from the I2C bus, wihtout using the FIFO.

	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if ((i2c->I2CMDR & I2C_I2CMDR_STP_BITS) == 1)
		return I2C_STP_NOT_READY_ERROR;

	// Check if bus busy
	if ((i2c->I2CSTR & I2C_I2CSTR_BB_BITS) == 1)
		return I2C_BUS_BUSY_ERROR;

	i2c->I2CMDR = 0; // Reset the I2C module before applying the new settings

	switch(msg->MsgType) {
		case I2C_MSG_EEPROM_24LC16:
			i2c->I2CCNT = 1;
			i2c->I2CSAR = msg->SlaveAddress + (((msg->MemoryAddr)>>8)&0x7);
			break;
		case I2C_MSG_GENERIC:
			i2c->I2CCNT = 1;
			i2c->I2CSAR = msg->SlaveAddress;
			break;
		default:
			return I2C_BAD_MSG_TYPE;
		}

	// Address the device
	i2c->I2CMDR = (I2C_I2CMDR_STT_BITS|I2C_I2CMDR_MST_BITS|I2C_I2CMDR_TRX_BITS|I2C_I2CMDR_IRS_BITS|I2C_I2CMDR_FREE_BITS); // Address the device
	while (!(i2c->I2CSTR & (I2C_I2CSTR_XRDY_BITS|I2C_I2CSTR_ARDY_BITS)))
				continue; // Wait until the communication takes place, and then check the ACK
	// Check the ACK from the slave, and signal a failure if not received
	if(i2c->I2CSTR & I2C_I2CSTR_NACK_BITS){
				// Slave not addressed. Fail.
				i2c->I2CMDR = 0;
				i2c->I2CSTR = I2C_I2CSTR_NACK_BITS; // Clear NACK bit
				return I2C_NACK_ERROR;
			}
	i2c->I2CDXR = msg->MemoryAddr; // Send the memory address
	// Make sure the I2C controller can be put into read mode before proceeding with the RD phase
	while (!(i2c->I2CSTR & (I2C_I2CSTR_XRDY_BITS|I2C_I2CSTR_ARDY_BITS)))
					continue; // Wait for ARDY before starting the RD phase

	i2c->I2CCNT = msg->NumOfBytes;	// Setup how many bytes to expect, and start the RD transfer cycle
	i2c->I2CMDR = (I2C_I2CMDR_STT_BITS|I2C_I2CMDR_STP_BITS|I2C_I2CMDR_MST_BITS|I2C_I2CMDR_IRS_BITS|I2C_I2CMDR_FREE_BITS);

	for (i = 0; i < msg->NumOfBytes; i++) {

	while (!(i2c->I2CSTR & (I2C_I2CSTR_RRDY_BITS|I2C_I2CSTR_ARDY_BITS)))
		continue; // Wait until the communication takes place, and then check the ACK
	// Check the ACK from the slave, and signal a failure if not received
	if(i2c->I2CSTR & I2C_I2CSTR_NACK_BITS){
				// Slave not addressed. Fail.
				i2c->I2CMDR = 0;
				i2c->I2CSTR = I2C_I2CSTR_NACK_BITS; // Clear NACK bit
				return I2C_NACK_ERROR;
			}
		while (!(i2c->I2CSTR & (I2C_I2CSTR_RRDY_BITS)))
					continue; // Make sure that RRDY is asserted before reading data
		*(msg->MsgBuffer + i) = i2c->I2CDRR;
	}

	while(i2c->I2CMDR & I2C_I2CMDR_MST_BITS)
			continue;
	return I2C_SUCCESS;
}

