
// **************************************************************************
// the includes

// drivers

// modules

// platforms
#include "defaults.h"


// **************************************************************************
// the defines


// **************************************************************************
// the globals


// **************************************************************************
// the functions


extern void Defaults_init(DEFAULTS_Memory *def)
{
	// In case the EEPROM won't work
	def->throttle[0].inverted = false;
	def->throttle[0].min_adc = _IQ(0.0);
	def->throttle[0].max_adc = _IQ(0.0);
	def->throttle[0].min_out = _IQ(0.0);
	def->throttle[0].max_out = _IQ(1.0);
	def->throttle[1].inverted = true;
	def->throttle[1].min_adc = _IQ(0.0);
	def->throttle[1].max_adc = _IQ(0.0);
	def->throttle[1].min_out = _IQ(0.0);
	def->throttle[1].max_out = _IQ(1.0);
	def->maxDiffPercent = _IQ(20.0);

	def->instaspin.fullscaleFreqHz = 550.0;
	def->instaspin.fullscaleVoltageV = 60.0;
	def->instaspin.adcFulscaleVoltageV = 470.0;
	def->instaspin.fullscaleCurrentA = 251.0;
	def->instaspin.adcFulscaleCurrentA = 510.0;
	def->instaspin.numCurrentSensors = 3;
	def->instaspin.offsetCurrentA = 0;
	def->instaspin.offsetCurrentB = 0;
	def->instaspin.offsetCurrentC = 0;
	def->instaspin.offsetVoltageA = 0;
	def->instaspin.offsetVoltageB = 0;
	def->instaspin.offsetVoltageB = 0;
	def->instaspin.offsetVoltageC = 0;
	def->instaspin.pwmFreqKHz = 15.0;
	def->instaspin.voltageFilterPoleHz = 473.464;

	def->motor.encoderLines = 4096;
	def->motor.motorType = MOTOR_Type_Pm;
	def->motor.numPolePairs = 4;
	def->motor.resRotor = NULL;
	def->motor.resStator = 0.003115789;
	def->motor.inductanceD = 0.0002503695;
	def->motor.inductanceQ = 0.0002503695;
	def->motor.ratedFlux = 0.29;
	def->motor.magnetizingCurrent = NULL;
	def->motor.resEstimationCurrent = 5.0;
	def->motor.indEstimationCurrent = -1.0;
	def->motor.maxCurrent = 15.0;
	def->motor.fluxEstimationFrequency = 50.0;

	return;
}


//! \brief     Sets up the throttle module parameters initially
//! \param[in] handle  The throttle handle
extern void THROTTLE_setParams(THROTTLE_Handle handle, THROTTLE_Defaults def)
{
  THROTTLE_Obj *obj = (THROTTLE_Obj *)handle;

  obj->flagSw1 = false;
  obj->flagSw2 = false;
  obj->params.max_adc = def.max_adc;
  obj->params.min_adc = def.min_adc;

  obj->params.max_out = def.max_out;
  obj->params.min_out = def.min_out;


  THROTTLE_calcParams(handle);

  return;
}

extern void THROTTLE_calcParams(THROTTLE_Handle handle) {
	THROTTLE_Obj *obj = (THROTTLE_Obj *)handle;
	  obj->slope = _IQdiv((obj->params.max_out - obj->params.min_out),(obj->params.max_adc - obj->params.min_adc));
	  obj->offset = obj->params.max_out - _IQmpy(obj->slope,obj->params.max_adc);

	  obj->state = THROTTLE_Run;
	  obj->value = _IQ(0.0);
	  //obj->inverted = invert;

}

extern void THROTTLE_setup(THROTTLE_Handle handle,      \
                                const _iq value,        \
                                const bool SW1,         \
                                const bool SW2)
{
  THROTTLE_Obj *obj = (THROTTLE_Obj *)handle;

  obj->flagSw1 = SW1;
  obj->flagSw2 = SW2;

  obj->value = value;

  return;
}


extern void THROTTLE_runState(THROTTLE_Handle handle)
{
  THROTTLE_Obj *obj = (THROTTLE_Obj *)handle;


  if(obj->flagSw1)
  {
    obj->result = _IQ(0.0);
    obj->state = THROTTLE_CalMaxMin;
    obj->params.max_adc = _IQ(0.0);//obj->min_out;		// Make sure this MAX always lower than real MAX
    obj->params.min_adc = _IQ(120.0); //obj->max_out;	// Make sure this MIN always higher than real MIN
  }
  else
  {
    switch (obj->state)
    {
    case THROTTLE_CalMaxMin:

      if (obj->value > obj->params.max_adc)
        obj->params.max_adc = obj->value;
      else if (obj->value < obj->params.min_adc)
        obj->params.min_adc = obj->value;
      else if (obj->flagSw2)
        obj->state = THROTTLE_CalCalc;

    break;

    case THROTTLE_CalCalc:
    {
      obj->slope = _IQdiv((obj->params.max_out - obj->params.min_out),(obj->params.max_adc - obj->params.min_adc));
      obj->offset = obj->params.max_out - _IQmpy(obj->slope,obj->params.max_adc);

      obj->state = THROTTLE_Run;
    }
    break;

    case THROTTLE_Run:
    {
      _iq result = _IQmpy(obj->value,obj->slope) + obj->offset;
      obj->result = _IQsat(result,obj->params.max_out,obj->params.min_out);
      if(obj->params.inverted)
    	  obj->result = obj->params.max_out - obj->result;
    }
    break;
    }
  }


  return;
}


