// UMC Drive 3 test script, using Motorware 16 and HV kit as soure

//! \defgroup PROJ_LAB01_OVERVIEW Project Overview
//!
//! CPU and Inverter Set-up and introduction to interfacing to the ROM library
//!

//
// **************************************************************************
// the includes

// system includes
#include <math.h>

// modules
#include "modules/math/src/32b/math.h"
#include "modules/memCopy/src/memCopy.h"

// drivers

// platforms
#include "main.h"

// **************************************************************************
// the defines

#define LED_BLINK_FREQ_Hz   5

// **************************************************************************
// the globals

uint_least32_t gLEDcnt = 0; // Counter used to divide down the ISR rate for visually blinking an LED

HAL_Handle halHandle;       // Handle to the Inverter hardware abstraction layer

USER_Params gUserParams;                      // Contains the user.h settings

HAL_PwmData_t gPwmData = { 0, 0, 0 }; // Contains PWM duty cycles in global Q format

HAL_AdcData_t gAdcData = { 0, 0, 0, 0, 0, 0, 0 }; // Contains Current and Voltage ADC readings in global Q format

HAL_AdcSec_t gAdcDataSec = { 0, 0, 0, 0, 0, 0, 0, 0 }; // Contains Current and Voltage ADC readings in global Q format

volatile MOTOR_Vars_t gMotorVars = MOTOR_Vars_INIT;

#ifdef FLASH
// Used for running BackGround in flash, and ISR in RAM
		extern uint16_t *RamfuncsLoadStart, *RamfuncsLoadEnd, *RamfuncsRunStart;

#ifdef F2802xF
		extern uint16_t *econst_start, *econst_end, *econst_ram_load;
		extern uint16_t *switch_start, *switch_end, *switch_ram_load;
#endif

#endif

// **************************************************************************
// the functions

void main(void) {
	// Only used if running from FLASH
	// Note that the variable FLASH is defined by the project
#ifdef FLASH
	// Copy time critical code and Flash setup code to RAM
	// The RamfuncsLoadStart, RamfuncsLoadEnd, and RamfuncsRunStart
	// symbols are created by the linker. Refer to the linker files.
	memCopy((uint16_t *)&RamfuncsLoadStart,(uint16_t *)&RamfuncsLoadEnd,(uint16_t *)&RamfuncsRunStart);

#ifdef F2802xF
	//copy .econst to unsecure RAM
	if(*econst_end - *econst_start)
	{
		memCopy((uint16_t *)&econst_start,(uint16_t *)&econst_end,(uint16_t *)&econst_ram_load);
	}

	//copy .switch ot unsecure RAM
	if(*switch_end - *switch_start)
	{
		memCopy((uint16_t *)&switch_start,(uint16_t *)&switch_end,(uint16_t *)&switch_ram_load);
	}
#endif

#endif

	// initialize the hardware abstraction layer
	halHandle = HAL_init(&hal, sizeof(hal));

	// check for errors in user parameters
	//USER_checkForErrors(&gUserParams);

	// store user parameter error in global variable
	gMotorVars.UserErrorCode = USER_getErrorCode(&gUserParams);
	gMotorVars.UserErrorCode = USER_ErrorCode_NoError;

	// do not allow code execution if there is a user parameter error
	if (gMotorVars.UserErrorCode != USER_ErrorCode_NoError) {
		for (;;) {
			gMotorVars.Flag_enableSys = false;
		}
	}

	// initialize the user parameters
	USER_setParams(&gUserParams);

	// set the hardware abstraction layer parameters
	HAL_setParams(halHandle, &gUserParams);

	// setup faults
	//HAL_setupFaults(halHandle);

	// initialize the interrupt vector table
	HAL_initIntVectorTable(halHandle);

	// enable the ADC interrupts
	HAL_enableAdcInts(halHandle);

	// enable the CAN interrupt 0
	//HAL_enableCANInts(halHandle);

	// enable the CAN interrupt 0
	HAL_enableSciRxInts(halHandle);

	// enable global interrupts
	HAL_enableGlobalInts(halHandle);

	// enable debug interrupts
	HAL_enableDebugInt(halHandle);

	// disable the PWM
	//HAL_disablePwm(halHandle);
	// enable PWMs
	HAL_enablePwm(halHandle);

	// For ever loop
	while (true)
		;

} // end of main() function

interrupt void mainISR(void) {

	// toggle status LED
	if (gLEDcnt++ > (uint_least32_t) (USER_ISR_FREQ_Hz / LED_BLINK_FREQ_Hz)) {
		HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);
		gLEDcnt = 0;
	}

	// acknowledge the ADC interrupt
	HAL_acqAdcInt(halHandle, ADC_IntNumber_1);

	// convert the ADC data
	HAL_readAdcData(halHandle, &gAdcData);
	HAL_readAdcSecondary(halHandle, &gAdcDataSec);

	// ADC processing and pwm result code goes here

	// write the PWM compare values
	HAL_writePwmData(halHandle, &gPwmData);

	return;
} // end of mainISR() function

interrupt void Can0ISR(void) {
	// How should we know which message was received?
	CAN_clearRxInt(((HAL_Obj *) halHandle)->canHandle,
			CAN_MBOX_1 | CAN_MBOX_2 | CAN_MBOX_3 | CAN_MBOX_4);
	HAL_acqCANInt(halHandle);
	HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);
	return;
}

interrupt
void SciaRxISR(void) {
	/*
	 SCI_write(((HAL_Obj *) halHandle)->sciHandle[0],
	 SCI_read(((HAL_Obj *) halHandle)->sciHandle[0]));
	 */

	uint16_t command = SCI_read(((HAL_Obj *) halHandle)->sciHandle[0]);
	SCI_write(((HAL_Obj *) halHandle)->sciHandle[0], command);
	switch (command) {
	case 'y':
		gMotorVars.Flag_enableSys = 1;
		gMotorVars.Flag_Run_Identify = 1;
		break;
	case 'n':
		gMotorVars.Flag_enableSys = 0;
		gMotorVars.Flag_Run_Identify = 0;
		break;
	default:
		break;
	}

	HAL_acqSciRxInt(halHandle);
	HAL_toggleLed(halHandle, (GPIO_Number_e) GPIO_Number_39);

	/* Example:
	 *  SciaRegs.SCIFFRX.bit.RXFFOVRCLR=1;   // Clear Overflow flag
	 *	SciaRegs.SCIFFRX.bit.RXFFINTCLR=1;   // Clear Interrupt flag
	 *  PieCtrlRegs.PIEACK.all|=0x100;       // Issue PIE ack
	 */

	return;
}

//@} //defgroup
// end of file

